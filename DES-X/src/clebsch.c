
#include "clebsch.h"
#include <stdio.h>


const uint8_t CLEBSCH_ADJACENCY_LIST[NUM_VERTICES][VERTEX_DEGREE] = {
    { 1,  2,  13,  8, 14},   // Vertex 0
    { 0,  4,  7,  9, 11},   // Vertex 1
    { 0,  3,  4, 10, 15},   // Vertex 2
    { 9,  2,  6, 11, 13},   // Vertex 3
    { 2,  1,  5,  6, 12},   // Vertex 4
    { 15,  4,  11,  9, 8},   // Vertex 5
    { 3,  4,  8, 7, 14},   // Vertex 6
    { 13,  6, 10, 15, 1},   // Vertex 7
    { 6,  9,  10, 0, 5},   // Vertex 8
    { 3,  8,  12, 15, 1},   // Vertex 9
    { 11,  2,  7,  8, 12},   // Vertex 10
    { 10,  3,  1, 5, 14},   // Vertex 11
    { 13,  14, 4, 10, 9},   // Vertex 12
    { 12,  7, 5, 3, 0},   // Vertex 13
    { 0,  6, 15, 11, 12},   // Vertex 14
    { 14,  9,  7, 2, 5}    // Vertex 15
};
uint64_t apply_permutation_choice_2(uint64_t input, const uint8_t* table, size_t output_size) {
    uint64_t output = 0;
    for (int i = 0; i < output_size; i++) {
        uint64_t bit = (input >> (56 - table[i])) & 1;  // Extract bit from 56-bit input
        output |= (bit << (output_size - i - 1));       // Assign to 48-bit output
    }
    return output;
}

// This function takes a 64-bit master key and a round number,
// and it returns a subkey generated by diffusing the key segments
// using the structure of the Clebsch graph.
uint64_t generate_subkey_graph(uint64_t master_key, uint8_t round) {

    // 1. Split master_key into 16 segments (each 4 bits)
    uint8_t segments[NUM_VERTICES];
    for (int i = 0; i < NUM_VERTICES; i++) {
        // Extract 4 bits from master_key.
        // We assume the leftmost 4 bits are segment 0, etc.
        segments[i] = (master_key >> ((NUM_VERTICES - 1 - i) * SEGMENT_BITS)) & 0xF;
    }

    // We perform a number of iterations to mix bits
    uint8_t iterations = round + 1;
    for (int iter = 0; iter < iterations; iter++) {
        uint8_t new_segments[NUM_VERTICES];
        for (int i = 0; i < NUM_VERTICES; i++) {
            uint8_t combined = segments[i];
            // For each neighbor of vertex i, XOR its segment value.
            for (int j = 0; j < 5; j++) {
                int neighbor =  CLEBSCH_ADJACENCY_LIST[i][j];
                combined ^= segments[neighbor];
            }
            new_segments[i] = combined;
        }
        // Update segments with the newly computed values.
        for (int i = 0; i < NUM_VERTICES; i++) {
            segments[i] = new_segments[i];
        }
    }

    // 3. Recombine the 16 segments into a 64-bit value.
    uint64_t subkey = 0;
    for (int i = 0; i < NUM_VERTICES; i++) {
        subkey |= ((uint64_t)segments[i] << ((NUM_VERTICES - 1 - i) * SEGMENT_BITS));
    }

    // 4.mask the subkey to 56 bits.
    subkey &= 0x00FFFFFFFFFFFFFF;

    return subkey;
}

uint64_t* get_all_subkeys(uint64_t master_key)
{
    uint64_t* subkeys;
    subkeys = (uint64_t*)malloc(NUM_OF_SUBKEYS * sizeof(uint64_t));
    for (int i = 0; i < NUM_OF_SUBKEYS; i++)
    {
        // Generate subkey
        subkeys[i] = generate_subkey_graph(master_key, i);
        // Apply PC2
        subkeys[i] = apply_permutation_choice_2(subkeys[i], PC2, 48);
    }



    return subkeys;
}
